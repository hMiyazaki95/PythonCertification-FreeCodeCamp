# Declare another variable called alphabet and assign the string abcdefghijklmnopqrstuvwxyz to this variable.
# alphabet = "abcdefghijklmnopqrstuvwxyz"
# shift = 5
# Create a variable named shifted_alphabet and use the slicing syntax to assign it the portion of alphabet that starts at the index of shift. Then, call the built-in print() function to print shifted_alphabet on the terminal and look at the result.
# shifted_alphabet = alphabet[shift:]
#Modify the existing assignment of the shifted_alphabet variable: use the slicing syntax to extract the missing first portion of alphabet and concatenate it to alphabet[shift:].

# # As a reminder, sentence[start:stop] returns the characters of sentence from position start (included) to stop (excluded).
# shifted_alphabet = alphabet[shift:] + alphabet[:shift]
# # print(shifted_alphabet)
# # fghijklmnopqrstuvwxyz
# # Now that you have your entire shifted alphabet, remove the print(shifted_alphabet) call.
# # You'll learn more about the type of structure returned by str.maketrans() later on in the curriculum. For now, create a translation table that maps the characters in alphabet to the characters in shifted_alphabet and assign it to a variable named translation_table.

# translation_table = str.maketrans(alphabet, shifted_alphabet)
# # Declare a new variable named text and assign it the string hello world. This will be the message to encrypt.
# text = "hello world"

# # The translate() method takes as argument the translation table generated by str.maketrans(). It is called on a string and returns a copy of the original string where the characters have been replaced based on the translation table:
# # Call the translate() method on text passing in the translation_table as the argument and assign the result to a variable named encrypted_text.
# # Call the translate() method on text passing in the translation_table as the argument and assign the result to a variable named encrypted_text.
# encrypted_text = text.translate(translation_table)
# print(encrypted_text)
# # mjqqt btwqi


# Create a function named caesar. Put all your existing code within the function body. Pay attention to keep the same indentation level for all of the lines within the function body.
# make code reusable
def caesar(text, shift, encrypt=True):
    if not isinstance(shift, int):
        return "Shift must be an integer value."
    # if shift < 1:
    #         return 'Shift must be a positive integer.'
    if shift < 1 or shift > 25:
            return 'Shift must be an integer between 1 and 25.'
    if not encrypt:
        shift = -shift
    
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    # shift = 5
    shifted_alphabet = alphabet[shift:] + alphabet[:shift]
    translation_table = str.maketrans(alphabet, shifted_alphabet)
    # text = 'hello world'
    encrypted_text = text.translate(translation_table)
    # print(encrypted_text)
    # return text.translate(translation_table)
    return encrypted_text
def encrypt(text, shift):
    return caesar(text, shift)

def decrypt(text, shift):
    return caesar(text, shift, encrypt=False)

# As you learned in a previous lesson, functions can have parameters, which are variables that can be referenced within the function. Here's a sum function with two parameters, num1 and num2.
# def sum(num1, num2):
#     print(num1 + num2)
# The message to encrypt and the shift are still hardcoded in your function. Give your function two parameters named text and shift, and delete the declarations of both the text and shift variables from the caesar function body.
# Now, test the caesar function by calling it with the string freeCodeCamp and the number 3 as the arguments. Assign the function call to a variable named encrypted_text.
# encrypted_text = caesar("freeCodeCamp", 3)
# encrypted_text = encrypt('freeCodeCamp', 3)
# Now your code is reusable. However, the caesar function prints a message on the terminal and gives back None by default. To prove it, print encrypted_text at the end of your code.
# print(encrypted_text)
# encrypted_text = encrypt('freeCodeCamp', 3)
encrypted_text = 'Pbhentr vf sbhaq va hayvxryl cynprf.'
decrypted_text = decrypt(encrypted_text, 13)
# print(encrypted_text)
print(decrypted_text)

# Update your str.maketrans() call by concatenating to each argument the uppercase version of the argument itself.
# At the beginning of your function body, create an if statement. For now, use True as the condition, and within the if statement body return the string Shift must be an integer value.

# The isinstance() function returns True if its first argument is an instance of the second argument, and False otherwise:

# Example Code
# print(isinstance('Hello World', str)) # True
# print(isinstance(42, int)) # True
# Replace the current condition of your if statement with an isinstance() call. Pass in shift as the first argument, and int as the second argument.

# As you recall from previous lessons, the not operator is a unary logical operator that negates an expression:

# Example Code
# print(not True) # False
# print(not False) # True
# Use the not operator to fix the condition of the if statement so that your function returns Shift must be an integer value. when shift is not an integer.

# A negative or null shift should not be accepted by your function. Therefore, after your first if statement, create another if statement that checks if shift is less than 1 and returns the string Shift must be a positive integer.

# As you've already verified, the shift passed to encrypt the text should be positive. It cannot exceed 25 (the last index of alphabet) though.

# Add a second condition to the if statement that verifies that shift is greater than 25. Remember that the logical OR operation in Python is implemented through the or operator.

# Also, update the returned message to Shift must be an integer between 1 and 25.

# Python allows you to specify a default value for the parameters in a function, creating a function that can be called with fewer or no arguments. Here's how to create a function with a name parameter that has a default value:

# Example Code
# def greet(name='Polly'):
#     return 'Hello ' + name
    
# print(greet()) # Hello Polly
# Add a third parameter named encrypt to your function and give it a default value of True.

# You are going to use the parameter added in the previous step to determine if the function should encrypt the text passed to it (default behavior, encrypt=True), or if it should decrypt an encrypted message.

# Create an if statement that checks if encrypt is not truthy. Within the new if statement, set shift to - shift. This is necessary to enable the shift to take place in the opposite direction with respect to the encryption process.

# Declare two functions named encrypt and decrypt, both with text and shift parameters.

# You'll use encrypt for the encryption process, and decrypt for the decryption, labeling the two actions with a descriptive name.

# Return a caesar call passing in text and shift from both your new functions, but make sure to pass in also False as the third argument for the decrypt function.
# Step 24
# It's time to test the encrypt function. Using the same arguments, replace your caesar call with a call to encrypt. You'll see the same output on the terminal.

# Now you're going to test the decrypt function. Replace the value assigned to encrypted_text with the following string, which represents a message to decrypt: Pbhentr vf sbhaq va hayvxryl cynprf.

# Then, declare a variable named decrypted_text and assign it a call to decrypt with encrypted_text as it first argument and a shift of 13 as the second argument.

# Finally, print the decrypted_text on the terminal. With that, the Caesar cipher is complete.